<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ include file="Core.tt"  #>

using System;
using System.Collections;
using System.Collections.Generic;

namespace Functional.Fluent
{
	public static class ResultExtensions2
    {

	<# for (int i = 3; i <= 7; ++i)
	{
	#>
    
	public static AggregateResult<<#= ListTypes(i - 1) #>> And <<#= ListTypes(i - 1) #>> (this AggregateResult<<#= ListTypes(i - 2) #>> result, Result<T<#= i #>> other) =>
		result.IsSucceed && other.IsSucceed ? Result.Success(Tuple.Create(<#
			for (int j = 1; j < i; ++j)
			{ #>result.Value.Item<#= j#>, <# }		
		#>other))
            : Result.Fail(Tuple.Create(<#
			for (int j = 1; j < i; ++j)
			{ #>result.Value.Item<#= j#>, <# }		
		#>other));

		public static AggregateResult<<#= ListTypes(i - 1) #>> Or <<#= ListTypes(i - 1) #>> (this AggregateResult<<#= ListTypes(i - 2) #>> result, Result<T<#= i #>> other) =>
		result.IsSucceed || other.IsSucceed ? Result.Success(Tuple.Create(<#
			for (int j = 1; j < i; ++j)
			{ #>result.Value.Item<#= j#>, <# }		
		#>other))
            : Result.Fail(Tuple.Create(<#
			for (int j = 1; j < i; ++j)
			{ #>result.Value.Item<#= j#>, <# }		
		#>other));
	

	<#
    }
	#>

	}

	public static partial class Result
    {

	<# for (int i = 2; i <= 7; ++i)
	{
	#>
    
	internal static AggregateResult<<#= ListTypes(i - 1) #>> Success<<#= ListTypes(i - 1) #>>(Tuple<<#= ListResultTypes(i - 1) #>> value) => new AggregateResult<<#= ListTypes(i - 1) #>>(true, value);

	internal static AggregateResult<<#= ListTypes(i - 1) #>> Fail<<#= ListTypes(i - 1) #>>(Tuple<<#= ListResultTypes(i - 1) #>> value) => new AggregateResult<<#= ListTypes(i - 1) #>>(false, value);
	

	<#
    }
	#>

	}

	<# for (int i = 2; i <= 7; ++i)
	{
	#>

	public class AggregateResult<<#= ListTypes(i - 1) #>> : Result<Tuple<<#= ListResultTypes(i - 1) #>>>, IEnumerable<IResult>
	{

		public AggregateResult(bool isSucceed) : base(isSucceed)
	    {
	    }

	    public AggregateResult(bool isSucceed, Tuple<<#= ListResultTypes(i - 1) #>> value) : base(isSucceed, value)
	    {
	    }

	    public IEnumerator<IResult> GetEnumerator()
	    {
			<# for (int j = 1; j <= i; ++j) { #>
				yield return Value.Item<#= j #>;
			<# } #>
	    }

	    IEnumerator IEnumerable.GetEnumerator()
	    {
	        return GetEnumerator();
	    }

		public Tuple<<#= ListTypes(i - 1) #>> AggregateValue
        {
            get
            {
                if (IsSucceed)
                    return Tuple.Create(<# for (int j = 1; j <= i; ++j) { #>WrappedValue.Item<#= j #>.Value <# if (j < i) { #> , <# } #><# } #>);
                throw new ApplicationException("Cannot obtain value for not succeed result");
            }
        }
	
	}
	<#
    }
	#>
}